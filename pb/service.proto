syntax = "proto3";

package service;
import "google/protobuf/struct.proto";
option go_package = "/service";

/***
  NOTE: 定义Master处的接口
***/
service RappaMaster {
  // CommitSlot Executor向Master提交自己完成的Task Slot
  rpc CommitSlot (SlotCommitRequest) returns (SlotCommitResponse);
  //  rpc CommitProof (ProofCommitRequest) returns (ProofCommitResponse); // TODO DataProver向Master提交自己完成的Proof
}

/***
  NOTE: 定义Executor处的接口
***/
service RappaExecutor {
  // Heartbeat 向follower同步slot状态，同时监控节点状态
  rpc Heartbeat (HeartbeatRequest) returns (HeartbeatResponse);
  // Schedule 用于向节点发送调度
  rpc Schedule(ScheduleRequest) returns (ScheduleResponse);

  // Collect 用于向节点收集chunk，恢复文件数据
  rpc Collect(RecoverRequest) returns (RecoverResponse);
}






//// 这个是layer端的服务协议
//service Coordinator {
//  // Commit 节点向Coordinator返回自己已经完成的Task Slot
//  rpc CommitSlot (SlotCommitRequest) returns (SlotCommitResponse);
//  // TODO: 这里有一个提交proof的接口，先不实现
//  //  rpc CommitProof (ProofCommitRequest) returns (ProofCommitRespnse);
//
//}
//
//// 这个是节点端的服务协议
//service NodeExecutor{
//  // Heartbeat 向follower同步slot状态，同时监控节点状态
//  rpc Heartbeat (HeartbeatRequest) returns (HeartbeatResponse);
//
//  // Schedule 用于向节点发送调度
//  rpc Schedule(ScheduleRequest) returns (ScheduleResponse);
//}

// 定义 JustifiedSlot 消息
message JustifiedSlot {
  int32 nid = 1;          // 节点ID
  int32 process = 2;      // 进程ID
  string sign = 3;        // 签名
  int32 slot = 4;         // 槽位ID
  int32 epoch = 5;        // 提交的epoch
  bytes commitment = 6; // 提交slot的时候向Master承诺，自己生成的数据文件的commitment
  repeated int32 padding = 7; // 所有的row chunk的padding size
  int32 store = 8; // 存储方式
  // state字段省略
}

// Heartbeat request message
message HeartbeatRequest {
  map<string, bytes> commits = 1;     // 提交的CommitSlotItem列表
  map<string, bytes> justifieds = 2;
  map<string, bytes> finalizes = 3;   // 完成的CommitSlotItem列表
  map<string, int32> invalids = 4;    // 这个epoch中检测出的有问题的slot
  //  map<string, int32> tasks = 3;            // 在这个epoch中过期的任务的最新slot
  int32 epoch = 5;
}

// Heartbeat response message

message HeartbeatResponse {
  int32 nodeId = 1;               // 节点id
  map<string, string> nodeStatus = 2; // 节点状态，这里先不管，可以加点cpu利用率、内存啥的
  repeated Vote votes = 3; // 投票
}

// EpochVote response message
message Vote {
  //  JustifiedSlot slot = 1; // 投票针对的内容
  //  int32 nodeId = 2;           // Node ID of the sender
  //  bool state = 3; // 是否同意
  //  string desp = 4; // 原因
  string hash = 1; // 投票针对的slot的哈希，这里暂时都写string，后续可以改成bytes,sign_slot_nid
  int32 nodeId = 2;           // Node ID of the sender
  bytes commitment = 3; // slot的承诺
  bool state = 4; // 是否同意
  string desp = 5; // 原因
}

message ScheduleRequest {
  string sign = 1; // 任务标记
  int32 slot = 2;
  //  int32 size = 3; // 数据总量
  //  map<string, int32> schedule = 4; // 分配，节点id: 数据量
  int32 nodeID = 3; // 节点ID
  int32 size = 4; // 给该节点的任务数量
  string model = 5; // 模型名称
  // 用于得到model params
  google.protobuf.Struct params = 6;       // Dynamic details, accepts JSON-like structures
  string hash = 7; // Slot Hash
}
message ScheduleResponse {
  bool accept = 1; // 是否同意该调度
  string nodeId = 2;
  string sign = 3;
  string errorMessage = 4; // 拒绝的理由
}

message SlotCommitRequest {
  int32 nodeId = 1;
  string sign = 2;
  int32 slot = 3;
  int32 size = 4;
  bytes commitment = 5;
  string hash = 6;
  repeated int32 padding = 7;
  int32 store = 8; // 存储方式,0=ec; 1=local; 2=replicas
  string errorMessage = 9;// 可能有一些说明，比如没有完全完成
}
message SlotCommitResponse {
  //  string valid = 1; // 你的提交是否合法，给个枚举,这个感觉没啥必要
  bytes seed = 1; // 传给节点一个随机值，用于生成随机的hash
  string hash = 2; // 给节点一个标识用来标识这个slot，用于后续查看heartbeat
  int32 timeout = 3; // 传给节点一个时限，用于说明多少时间后需要传递一个zkp证明以及多久后开始投票，暂定不可变
  //  string sign = 2; //
  //  string slot = 3; // 合法的slot
}


message RecoverRequest {
  string mission = 1;
  repeated string hashs = 2; // 所有要收集的slotHash
}
// 每个chunk，这里是行块的ec块
message RecoverSlotChunk {
  string hash = 1; // slot hash
  int32 row = 2; // 行块对应的index
  int32 col = 3; // ec的index
  bytes chunk =4; // chunk的内容
}
message RecoverResponse {
  repeated RecoverSlotChunk chunks = 1; // 本地的对应的chunks
}